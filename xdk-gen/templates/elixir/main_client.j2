defmodule Xdk do
  @moduledoc """
  Auto-generated X API client.

  Uses Finch for HTTP transport and supports bearer token authentication.
  """

  @version "{{ version }}"

  defstruct [
    :base_url,
    :finch,
    :bearer,
    :headers
  ]

  @type t :: %__MODULE__{
          base_url: String.t(),
          finch: atom(),
          bearer: String.t() | nil,
          headers: [{String.t(), String.t()}]
        }

  @spec new(keyword()) :: t()
  def new(opts \\ []) do
    %__MODULE__{
      base_url: Keyword.get(opts, :base_url, "https://api.x.com"),
      finch: Keyword.get(opts, :finch, Xdk.Finch),
      bearer: Keyword.get(opts, :bearer),
      headers: Keyword.get(opts, :headers, [])
    }
  end

  @spec request(t(), atom(), String.t(), keyword()) ::
          {:ok, term()} | {:error, Exception.t()}
  def request(%__MODULE__{} = client, method, path, opts \\ []) do
    params = Keyword.get(opts, :params, %{})
    query = Keyword.get(opts, :query, [])
    body = Keyword.get(opts, :json)

    url = client.base_url <> interpolate_path(path, params)

    url =
      case query do
        [] -> url
        _ -> url <> "?" <> URI.encode_query(query)
      end

{% raw %}
    headers =
      [{"user-agent", "xdk-elixir/#{@version}"}]
      |> Kernel.++(client.headers)
      |> maybe_add_bearer(client.bearer)
{% endraw %}

    encoded_body =
      case body do
        nil -> nil
        data -> Jason.encode!(data)
      end

    headers =
      if encoded_body do
        [{"content-type", "application/json"} | headers]
      else
        headers
      end

    method
    |> Finch.build(url, headers, encoded_body)
    |> Finch.request(client.finch)
    |> handle_response()
  end

{% raw %}
  defp interpolate_path(path, params) do
    Enum.reduce(params, path, fn {k, v}, acc ->
      String.replace(acc, "{#{k}}", URI.encode_www_form(to_string(v)))
    end)
  end

  defp maybe_add_bearer(headers, nil), do: headers
  defp maybe_add_bearer(headers, token), do: [{"authorization", "Bearer #{token}"} | headers]
{% endraw %}

  defp handle_response({:ok, %Finch.Response{status: status, body: body, headers: headers}})
       when status in 200..299 do
    case decode_body(body, headers) do
      {:ok, decoded} -> {:ok, decoded}
      {:error, reason} -> {:error, Xdk.Errors.Unknown.UnknownError.exception(error: reason)}
    end
  end

  defp handle_response({:ok, %Finch.Response{status: status, body: body, headers: headers}}) do
    decoded =
      case decode_body(body, headers) do
        {:ok, d} -> d
        _ -> body
      end

    {:error, Xdk.Errors.ApiError.exception(status: status, body: decoded)}
  end

  defp handle_response({:error, reason}) do
    {:error, Xdk.Errors.TransportError.exception(reason: reason)}
  end

  defp decode_body("", _headers), do: {:ok, nil}
  defp decode_body(nil, _headers), do: {:ok, nil}

  defp decode_body(body, headers) do
    content_type =
      Enum.find_value(headers, "", fn
        {"content-type", v} -> v
        _ -> nil
      end)

    if String.contains?(content_type, "application/json") do
      Jason.decode(body)
    else
      {:ok, body}
    end
  end
end
